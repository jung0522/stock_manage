# 타임리프 가이드 🌱

branch : thymeleaf-basic
## 📁 현재 프로젝트 구조
```
src/main/resources/templates/
├── post/              # 게시글 관련 페이지
│   ├── list.html
│   ├── form.html
│   └── show.html
└── index.html         # 메인 페이지

```

## 📖 목차
1. [타임리프 기본 개념](#1-타임리프-기본-개념)
2. [텍스트 표시하기](#2-텍스트-표시하기)
3. [링크 만들기](#3-링크-만들기)
4. [조건문 사용하기](#4-조건문-사용하기)
5. [반복문으로 리스트 만들기](#5-반복문으로-리스트-만들기)
6. [폼 다루기](#6-폼-다루기)

---

## 1. 타임리프 기본 개념

타임리프는 HTML 파일에 특별한 속성을 추가해서 동적인 웹페이지를 만드는 도구입니다.

### 기본 설정
```html
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>내 웹사이트</title>
</head>
<body>
    <!-- 여기에 타임리프 코드를 작성합니다 -->
</body>
</html>
```

**포인트:**
- `xmlns:th="http://www.thymeleaf.org"` 선언 필요- 권장
- `th:` 로 시작하는 속성을 사용할 수 있음

---

## 2. 텍스트 표시하기

### 2-1. 기본 텍스트 출력 (`th:text`)

**컨트롤러에서 데이터 전달:**
```java
@GetMapping("/")
public String home(Model model) {
    model.addAttribute("username", "홍길동");
    model.addAttribute("message", "안녕하세요!");
    return "index";
}
```

**HTML에서 텍스트 표시:**
```html
<h1 th:text="${username}">기본값</h1>
<p th:text="${message}">기본 메시지</p>

```

**결과:**
```html
<h1>홍길동</h1>
<p>안녕하세요!</p>
```

### 2-2. HTML 내용 그대로 출력 (`th:utext`)

```html
<!-- 이스케이프 처리됨 (안전함) -->
<p th:text="${htmlContent}"></p>

<!-- HTML 태그가 그대로 적용됨 (주의!) -->
<p th:utext="${htmlContent}"></p>
```

th:utext는 에디터 본문등 필요한 부분에만 주의 깊게 사용 권장

### 2-3. 텍스트 조합하기

```html
<!-- 방법 1: + 연산자 사용 -->
<p th:text="'안녕하세요, ' + ${username} + '님!'">인사말</p>

<!-- 방법 2: |...| 리터럴 사용 (추천) -->
<p th:text="|안녕하세요, ${username}님!|">인사말</p>
```

---

## 3. 링크 만들기

### 3-1. 기본 링크 (`th:href`)

```html
<!-- 일반 링크 -->
<a th:href="@{/posts}">게시글 목록</a>

<!-- 패스 파라미터가 있는 링크 -->
<a th:href="@{/posts/{id}(id=${post.id})}">게시글 보기</a>

<!-- 쿼리 파라미터가 있는 링크 -->
<a th:href="@{/posts(page=${currentPage}, size=10)}">페이지</a>
```

### 3-2. 우리 프로젝트 예시

**게시판 목록에서:**
```html
<!-- post/list.html -->
<a th:href="@{/posts/new}" class="btn">글쓰기</a>
<a th:href="@{/posts/{id}(id=${post.id})}" th:text="${post.title}">제목</a>
```

**헤더에서:**
```html
<!-- index.html, list.html 등의 헤더 부분 -->
<header class="bg-white shadow sticky top-0 z-50">
    <div class="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
        <a th:href="@{/}" class="text-2xl font-bold text-blue-600">goorm board</a>
        <nav>
            <a th:href="@{/posts}" class="px-4 py-2 text-gray-600 hover:text-blue-600">게시판</a>
        </nav>
    </div>
</header>
```

**포인트:**
- `@{...}` 문법으로 URL을 만들어요
- `{id}`는 경로 변수, `(id=${post.id})`는 값 전달
- `(page=${currentPage}, size=10)`은 쿼리 파라미터


Thymeleaf에서는 `href="/posts"` 대신 `th:href="@{/posts}"`를 써야 하는 이유.

### 1. 절대 경로 vs 동적 경로

- `href="/posts"`  
    → HTML에 **하드코딩된 정적 경로**입니다. 서버 컨텍스트 경로나 배포 경로와 무관하게 항상 `/posts`로 고정됩니다.
    
- `th:href="@{/posts}"`  
    → Thymeleaf의 **URL 표현식**을 사용한 동적 경로입니다. Spring MVC에서 설정된 **contextPath**(예: `/app`)를 자동으로 붙여줍니다.  
    예: `http://localhost:8080/app/posts`
    

- 실제 서버에 배포할 때는 보통 `/`가 아닌 다른 경로(`/app`, `/my-service`)로 동작하는 경우가 많습니다.
    
- `href="/posts"`로 작성하면 컨텍스트 경로가 무시되어 링크가 깨집니다.
    
- `th:href="@{/posts}"`는 `@{}` 구문이 컨텍스트 경로를 인식해 `http://서버주소/컨텍스트/posts`로 올바르게 만들어줍니다.
   

### 2. URL 파라미터 처리

- `@{}` 문법은 단순히 경로만이 아니라 **쿼리 파라미터**도 편하게 붙일 수 있습니다.
    
    ```html
    <a th:href="@{/posts(page=${page}, size=${size})}">목록</a>
    ```
    
    → `/posts?page=1&size=10` 자동 생성
    

---

## 4. 조건문 사용하기

### 4-1. `th:if` / `th:unless`

```html
<!-- 조건이 참일 때만 보여줌 -->
<div th:if="${user != null}">
    <p th:text="|환영합니다, ${user.name}님!|"></p>
</div>

<!-- 조건이 거짓일 때만 보여줌 -->
<div th:unless="${user != null}">
    <p>로그인해주세요.</p>
</div>
```

### 4-2. 여러 조건 처리

```html
<!-- 여러 조건 -->
<div th:if="${posts != null and !posts.empty}">
    <p>게시글이 있습니다.</p>
</div>

<div th:if="${posts == null or posts.empty}">
    <p>게시글이 없습니다.</p>
</div>
```

### 4-3. 메시지 처리

```html
<!-- 에러 메시지 표시 -->
<div th:if="${error}" class="error-message">
    <p th:text="${error}">오류 메시지</p>
</div>

<!-- 성공 메시지 표시 -->
<div th:if="${success}" class="success-message">
    <p th:text="${success}">성공 메시지</p>
</div>
```

---

## 5. 반복문으로 리스트 만들기

### 5-1. 기본 반복문 (`th:each`)

**컨트롤러:**
```java
@GetMapping("/posts")
public String list(Model model) {
    List<Post> posts = postService.findAll();
    model.addAttribute("posts", posts);
    return "post/list";
}
```

**HTML:**
```html
<table>
    <tr th:each="post : ${posts}">
        <td th:text="${post.id}">1</td>
        <td th:text="${post.title}">제목</td>
        <td th:text="${post.author}">작성자</td>
    </tr>
</table>
```

### 5-2. 반복 상태 정보 사용하기

```html
<table>
    <tr th:each="post, status : ${posts}">
        <td th:text="${status.count}">순번</td>        <!-- 1부터 시작 -->
        <td th:text="${status.index}">인덱스</td>       <!-- 0부터 시작 -->
        <td th:text="${post.title}">제목</td>
        <td th:text="${status.first ? '첫번째' : ''}">첫번째</td>
        <td th:text="${status.last ? '마지막' : ''}">마지막</td>
    </tr>
</table>
```

### 5-3. 우리 프로젝트 예시

```html
<!-- post/list.html -->
<tbody class="bg-white divide-y divide-gray-200">
    <tr th:each="post : ${posts}">
        <td th:text="${post.id}" class="px-6 py-4">번호</td>
        <td class="px-6 py-4">
            <a th:href="@{/posts/{id}(id=${post.id})}" 
               th:text="${post.title}" 
               class="text-blue-600 hover:underline">제목</a>
        </td>
        <td th:text="${post.author}" class="px-6 py-4">작성자</td>
        <td th:text="${#temporals.format(post.createdAt, 'yyyy-MM-dd')}" class="px-6 py-4">작성일</td>
        <td th:text="${post.viewCount}" class="px-6 py-4">조회수</td>
    </tr>
</tbody>
```


### 정리

1. **DB에서 정렬만 내림차순 처리**
    
    ```sql
    SELECT * FROM posts ORDER BY id DESC;
    ```
    
    → 이 상태에서 Thymeleaf에서
    
    ```html
    <td th:text="${status.count}">순번</td>
    ```
    
    → 출력: `1, 2, 3 ...` (id는 10, 9, 7, 6…이더라도 순번은 연속됨)
    
2. **총 개수 기반 내림차순 순번**
    
    ```html
    <td th:text="${total - status.index}">순번</td>
    ```
    
    → 출력: `10, 9, 8 ...` (전체 개수를 기준으로 역순 번호)
    

---

## 6. 폼 다루기

### 6-1. 기본 폼

```html
<form th:action="@{/posts}" method="post"> 
	<!-- name 속성으로 데이터 전송 --> 
	 <input type="text" id="title" name="title" placeholder="제목을 입력하세요"> 
	 <textarea name="content" placeholder="내용을 입력하세요"></textarea> 
	 <button type="submit">저장</button> 
</form>
```

- HTML의 **`name` 속성**을 기준으로 값이 넘어감
- Spring MVC에서는 컨트롤러 메서드 파라미터로 바로 매핑됨

   ```java
    @PostMapping("/posts") 
    public String savePost(String title, String content) { 
        // name="title" → title 파라미터로 자동 매핑
        // name="content" → content 파라미터로 자동 매핑
    }
    ```

**Spring MVC의 자동 매핑 규칙:**

1. **파라미터명 기반 매핑** - HTTP 요청의 파라미터 이름과 메서드 파라미터 이름이 같으면 자동 매핑
2. **객체 필드 매핑** - HTTP 요청의 파라미터 이름과 객체의 필드명이 같으면 자동 매핑

**언제 어노테이션이 필요한가?**

```java
// 파라미터 이름이 다를 때만 @RequestParam 필요
@PostMapping("/posts")
public String savePost(@RequestParam("title") String postTitle) { 
    // name="title" → postTitle 파라미터
}

// 필수가 아닌 파라미터일 때
@PostMapping("/posts")
public String savePost(@RequestParam(required = false) String title) { 
    // title이 없어도 에러 안남
}
```

그래서 이름이 일치할 때는 어노테이션 없이도 깔끔하게 작동합니다!
- 단점:
    - name 속성과 Java 객체의 필드 이름이 반드시 일치해야 함
    - 값이 미리 채워져야 할 때(`수정 폼`)는 일일이 `${post.title}` 같은 EL을 써야 함
    - 검증 오류 시 값 유지가 불편함

### 6-2. 객체와 연결된 폼 (`th:object`)

```java
@GetMapping("/posts/new")
public String newPost(Model model) {
    // 빈 Post 객체를 모델에 추가 (폼과 연결하기 위해)
    model.addAttribute("post", new Post());
    return "post/form";
}
```


```html
<!-- th:object로 폼과 객체 연결 -->
<form th:action="@{/posts}" th:object="${post}" method="post">
    <!-- th:field는 객체의 필드와 자동 연결 -->
    <!-- *{title}은 post.title과 같음 -->
    <input type="text" th:field="*{title}" placeholder="제목">
    <!-- 자동으로 name="title", id="title" 생성 -->
    
    <input type="text" th:field="*{author}" placeholder="작성자">
    <!-- 자동으로 name="author", id="author" 생성 -->
    
    <textarea th:field="*{content}" placeholder="내용"></textarea>
    <!-- 자동으로 name="content", id="content" 생성 -->
    
    <button type="submit">저장</button>
</form>
```


```java
@PostMapping("/posts")
public String savePost(@ModelAttribute Post post) { 
    // th:object="${post}"와 연결된 Post 객체로 자동 매핑
    // th:field="*{title}" → post.title
    // th:field="*{author}" → post.author  
    // th:field="*{content}" → post.content
    
    postService.save(post);
    return "redirect:/posts";
}
```

**@ModelAttribute의 역할:**

- `th:object`로 연결된 객체를 받을 때 사용
- 생략해도 되지만 명시적으로 쓰는 게 좋음

  
**장점:**
- `th:field`가 자동으로 `name`, `id`, `value` 속성 생성
- 객체의 값이 자동으로 폼에 채워짐 (수정 폼에서 유용)
- 검증 오류 시 입력값 자동 유지
- 타입 안전성 확보 (컴파일 시점에 필드명 검증)

### 💡 권장사항
**실무에서는 `th:object` 방식을 사용하세요!**
- 기본 폼은 간단한 예제용
- 실제 프로젝트에서는 객체 연결 방식이 훨씬 유지보수하기 좋음
- Spring Boot의 표준 패턴


### 6-3. 우리 프로젝트 예시

```html
<!-- post/form.html -->
<form th:action="@{/posts}" th:object="${post}" method="post" 
      class="bg-white p-6 rounded shadow space-y-6">
    <h1 class="text-2xl font-bold">글쓰기</h1>
    <div>
        <label class="block text-sm font-medium mb-1" for="title">제목</label>
        <input type="text" th:field="*{title}" required 
               class="w-full border rounded px-4 py-2" />
    </div>
    <div>
        <label class="block text-sm font-medium mb-1" for="content">내용</label>
        <textarea th:field="*{content}" rows="8" required 
                  class="w-full border rounded px-4 py-2"></textarea>
    </div>
    <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded">저장</button>
</form>
```

---

## 💡 자주하는 실수

1. **네임스페이스 빼먹기**: `xmlns:th="http://www.thymeleaf.org"` 권장!
2. **URL 문법**: `href="/posts"`가 아니라 `th:href="@{/posts}"`
3. **텍스트 표시**: `<p>${username}</p>`가 아니라 `<p th:text="${username}"></p>`
4. **조건문**: `th:if="${posts.size() > 0}"`보다는 `th:if="${!posts.empty}"`

## 🔗 추가 학습 자료

- [타임리프 공식 문서](https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html)


---